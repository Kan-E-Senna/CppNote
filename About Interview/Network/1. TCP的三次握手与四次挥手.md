# 1. TCP的三次握手与四次挥手

## 三次握手

1. 客户端首先选取一个随机数作为序列号sequence number，（假设这个序列号为x），再将这个序列号与一个SYN=1的TCP报文绑定在一起，向服务端发送，以此来请求连接。而后客户端进入SYN-SENT的状态。
2. 服务端收到这个报文后，如果决定接收连接，就选取一个随机数作为序列号sequence number（称之为y），然后把这个序列号绑定在一个SYN=1（意思是建议连接），ACK=1（意思是确认客户端请求的连接有效），Ack = x+1，的报文上，然后发回给客户端。发送完毕后服务端置于SYN-RECV的状态。
3. 客户端收到服务端发回的报文，再回发一个ACK=1（意思是确认服务端发起的连接有效），Seq=x+1，Ack=y+1的报文给服务端。发送完毕后，客户端进入ESTABLISHED状态，服务端收到报文后，同样进入ESTABLISHED的状态。

![TCP三次握手](graphs\TCP三次握手.png)

## 四次挥手

1. 客户端首先发送FIN=1的报文通知服务端关闭连接，而后自身处于FIN-WAIT1的状态。
2. 服务端收到以后，回复一个ACK=1的报文，表示确认关闭，服务端处于CLOSE-WAIT的状态。
3. 但此时服务端可能仍有数据需要传输，因此会再传输一些数据之后，再发送一个FIN=1，ACK=1的报文，通知客户端关闭连接，而后服务端处于LAST-ACK的阶段。
4. 客户端收到后，回复一个ACK=1的报文，进入TIME-WAIT的状态，在等待两个MSL（最长报文段寿命）的时间后，进入CLOSE状态，服务端接收到这个报文后，也进入CLOSE状态。

<img src="graphs\TCP四次挥手.png" alt="TCP四次挥手" style="zoom:50%;" />

## Wireshark分析

![TCPconnWireshark](graphs\TCPconnWireshark.JPG)

这里的1408是客户端端口，8388是服务端端口。唯一与上文不同的是，第一次挥手（第4个包）中，客户端除了发送一个FIN=1，还发送了一个ACK=1。
