# 空指针作为函数参数

下面的函数是不对的，尽管编译不会报错：

```c++
void assi(int *p){
    p = new int {10};
}

int main() {
    int *q = new int{20};
    assi(q);
    std::cout << *q << std::endl; // The answer is 20;
    
    int *p = nullptr;
    assi(p);
    std::cout << *p << std::endl; // No output, and p == nullptr
    return 0;
}
```

这里的问题在于，传指针也是按值传递来的，也就是说assi的p和实际参数是两个东西。由此我们可能会想到传引用。但是，下面的写法虽然正确，但是也是有问题的：

```c++
void assi(int * &p){
    p = new int {10};
}

int main() {
    int *q = new int{20};
    assi(q);
    std::cout << *q << std::endl; // 10
    
    int *p = nullptr;
    assi(p);
    std::cout << *p << std::endl; // 10
    return 0;
}
```

这是传了一个指针的引用，这样运行就正确了。不过，这种做法事实上可能暗含有问题，而且不易理解。这里的问题在于，编译器很有可能在这里存在一个优化，就是把p的新地址放到主函数的栈中，而不是像往常一样放在函数栈中。为了少出问题，还是建议采用下面的写法，也就是显式地返回指针，也就是说我们显式地把指针的新值放到主函数栈里面。

```c++
int* assi(int *p){
    p = new int {10};
    return p;
}

int main() {
    int *p = nullptr;
    p = assi(p);
    std::cout << *p << std::endl;
    return 0;
}
```

## 问题的来源

我希望写一个函数，传入一个链表节点，而后放入不定个元素，用这些元素来初始化链表。一开始我是这样写的：

```c++
template<typename T>
void initVals(ListNode* node, T x){
    node = new ListNode{x};
}

template<typename T, typename ...V>
void initVals(ListNode* node, T x, V ...vals){
    node = new ListNode{x};
    initVals(node->next, vals...);
}

int main() {
    ListNode* head = nullptr;
    initVals(head, 4, 5, 6, 7, 8, 9);
    std::cout << head->val << std::endl; // no output, head == nullptr
    return 0;
}
```

但后来我发现链表无法被初始化。需要把ListNode* node变为引用。或者显式地返回，如下两个写法：

利用指针的引用：

```c++
template<typename T>
void initVals(ListNode* &node, T x){
    node = new ListNode{x};
}

template<typename T, typename ...V>
void initVals(ListNode* &node, T x, V ...vals){
    node = new ListNode{x};
    initVals(node->next, vals...);
}

int main() {
    ListNode* head = nullptr;
    initVals(head, 4, 5, 6, 7, 8, 9);
    output(head);
    return 0;
}
```

显式返回：

```c++
// Recommand
template<typename T>
ListNode* initVals(ListNode* node, T x){
    node = new ListNode{x};
    return node;
}

template<typename T, typename ...V>
ListNode* initVals(ListNode* node, T x, V ...vals){
    node = new ListNode{x};
    node->next = initVals(nullptr, vals...);
    return node;
}

int main() {
    ListNode* head = nullptr;
    head = initVals(head, 4, 5, 6, 7, 8, 9);
    output(head);
    return 0;
}
```

