## Lambda 匿名函数

匿名函数的声明方式为方括号圆括号花括号：[](){}。三个括号里面放置的东西各有不同。

先说圆括号和花括号，圆括号里面放参数，花括号里面放函数体，如下：

```c++
auto add = [](int x, int y) {return x+y;};
```

再来说方括号，我们的匿名函数如果需要使用一个不在堆中的外部变量（非全局变量），像这样：

```c++
int main(){
    int z{5};
    auto add = [](int x, int y){return x+y+z;}
}
```

这个写法是不对的，匿名函数不能像这样去引用外部变量，除非把z声明成全局变量。

问题出在方括号内，像这样的[]，里面什么都没有的[]意思是不引用任何外部变量。我们可以用[=]意思是，任何的外部变量，都靠值传递，或者[&]意思是，任何的外部变量，都靠引用传递。还有其它方式，如下表：

| 方式        | 含义                                            |
| ----------- | ----------------------------------------------- |
| []          | 不使用任何外部变量。                            |
| [=]         | 所有外部变量使用值传递                          |
| [&]         | 所有外部变量使用引用传递                        |
| [&x]        | x这一外部变量使用引用传递，不能使用其它外部变量 |
| [x]         | x这一外部变量使用值传递，不能使用其它外部变量   |
| [&x...]     | pack extension of x使用引用传递                 |
| [x...]      | pack extension of x使用值传递                   |
| [=, &x]     | x这一外部变量使用引用传递，其它外部变量值传递   |
| [&, x]      | x这一外部变量使用值传递，其它外部变量引用传递   |
| [x = expr]  | 利用expr表达式为x赋值，在函数体中使用           |
| [&x = expr] | 利用expr表达式为x的引用赋值，在函数体中使用     |

例子：

```c++
int main() {
    auto min{5};
    auto max{10};
    auto betwix = [min, max](int x) {return min <= x && x <= max;};
    std::vector<int> list{-1, 1,2, 0, 9, 7, 3, -23};
    auto cnt = std::count_if(list.begin(), list.end(), betwix);
    std::cout << cnt << std::endl;
    return 0;
}
```

