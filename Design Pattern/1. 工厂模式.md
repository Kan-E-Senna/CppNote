# 1. 工厂模式

工厂模式要求对象在创建的时候不可以直接把对象new出来，而是通过一个工厂对象来创建出来，把创建对象和使用对象分离。看下面的示例代码：

我们要有两种对象，一个是Creator，创建者，另一个是Product，是产品类。所有的Product都必须通过Creator来创建，而不可以私自new一个出来。

```c++
class Product{
public:
    virtual ~Product(){}
    virtual std::string Operation() const = 0;
};

class Creator{
public:
    virtual ~Creator(){};
    virtual Product* FactoryMethod() const = 0;

    std::string SomeOperation() const {
        Product *product = this->FactoryMethod();
        std::string result = "Creator: The same creator's code has just worked with" + product->Operation();
        delete product;
        return result;
    }
};
```

然后让所有的产品类都继承产品这个超类

```c++
class Product1: public Product{
public:
    std::string Operation() const override {
        return "{This is Product 1}"s;
    }
};

class Product2: public Product{
public:
    std::string Operation() const override {
        return "{This is Product 2}"s;
    }
};
```

然后再为每一种产品构建一个Creator类，让它们继承Creator这个超类。

```c++
class Creator1 : public Creator{
public:
    Product* FactoryMethod() const override {
        return new Product1;
    }
};

class Creator2 : public Creator{
public:
    Product* FactoryMethod() const override {
        return new Product2;
    }
};
```

这样就基本完成了工厂模式。

应用工厂模式的原因是我们可能经常不知道我们有多少种“产品”，但我们又必须向对象的使用者提供这些产品，而且必须让这些产品的接口一致。应用完工厂模式后，使用者只要直接调用对应的Creator接口即可，而不必关心创建时的复杂过程。

```c++
void Client(const Creator &creator){
    std::cout << "Client: I'm not aware of the creator's class, but it still works.\n"
              << creator.SomeOperation() << std::endl;
}
```

```c++
int main() {
    std::cout << "App: Launched with the ConcreteCreator1.\n";
    Creator* creator = new Creator1();
    Client(*creator);
    std::cout << std::endl;
    std::cout << "App: Launched with the ConcreteCreator2.\n";
    Creator* creator2 = new Creator2();
    Client(*creator2);

    delete creator;
    delete creator2;
    return 0;
}
```

输出：

```sh
App: Launched with the ConcreteCreator1.
Client: I'm not aware of the creator's class, but it still works.
Creator: The same creator's code has just worked with{This is Product 1}

App: Launched with the ConcreteCreator2.
Client: I'm not aware of the creator's class, but it still works.
Creator: The same creator's code has just worked with{This is Product 2}
```

