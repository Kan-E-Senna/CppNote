# 3. 生成器

有时我们想要构建的对象可能过于复杂，如果希望一次性构造完成，可能需要一个非常庞大的构造函数，这个构造函数可能有数十甚至数百个参数，这样会使得代码过于复杂。构造这种对象的时候，经常注意到的一个特点就是，其实很多参数是用不到的。它可能对构造一个特殊的对象有用，但对构造另一个对象就没用了。譬如，我们希望构造一个“房子”的对象，那么有关游泳池的参数对有些房子可能就是没用的。生成器模式就是说，我们把所有对象的共性提取出来，然后通过生成器再添加新特性。比如生成一个带游泳池和草坪的房子，可以先调用简单的构造函数生成一个简单地毛坯房，然后再调用生成器舔砖加瓦，再调用生成器构建游泳池和草坪。

样例代码：

我们首先有一个产品 (Product)和一个建造者 (Builder)。

```c++
class Product1{
    public:
    std::vector<std::string> parts_;
    void ListParts()const{
        std::cout << "Product parts: ";
        for (size_t i=0;i<parts_.size();i++){
            if(parts_[i]== parts_.back()){
                std::cout << parts_[i];
            }else{
                std::cout << parts_[i] << ", ";
            }
        }
        std::cout << "\n\n"; 
    }
};
```

```c++
class Builder{
    public:
    virtual ~Builder(){}
    virtual void ProducePartA() const =0;
    virtual void ProducePartB() const =0;
    virtual void ProducePartC() const =0;
};
```

这个产品有三个部分，但我们不在构造函数里面全部体现这三个部分。

接着具体化建造者：

```c++
class ConcreteBuilder1 : public Builder{
private:
    Product1* product;
public:
    ConcreteBuilder1(){ this->Reset();}
    ~ConcreteBuilder1(){ delete product; }

    void Reset() { this->product= new Product1();}
    void ProducePartA()const override { this->product->parts_.push_back("PartA1");}
    void ProducePartB()const override { this->product->parts_.push_back("PartB1"); }
    void ProducePartC()const override { this->product->parts_.push_back("PartC1"); }
    
    Product1* GetProduct() {
        Product1* result= this->product;
        this->Reset();
        return result;
    }
};
```

可以看到，建造者是把产品的三个部分用三个函数来进行生成。

我们当然可以直接使用builder的一个具体类，不过通常来说，我们可能更倾向于再添加一个主管类来管理builder，以防我们可能有多个builder。

```c++
class Director{
private:
    Builder* builder;
public:
    void set_builder(Builder* builder){ this->builder=builder; }

    void BuildMinimalViableProduct(){this->builder->ProducePartA(); }
    
    void BuildFullFeaturedProduct(){
        this->builder->ProducePartA();
        this->builder->ProducePartB();
        this->builder->ProducePartC();
    }
};
```

然后我们就可以让我们的使用者与Director对接了。

```c++
void ClientCode(Director& director)
{
    ConcreteBuilder1* builder = new ConcreteBuilder1();
    director.set_builder(builder);
    std::cout << "Standard basic product:\n"; 
    director.BuildMinimalViableProduct();
    
    Product1* p= builder->GetProduct();
    p->ListParts();
    delete p;

    std::cout << "Standard full featured product:\n"; 
    director.BuildFullFeaturedProduct();

    p= builder->GetProduct();
    p->ListParts();
    delete p;

    std::cout << "Custom product:\n";
    builder->ProducePartA();
    builder->ProducePartC();
    p=builder->GetProduct();
    p->ListParts();
    delete p;

    delete builder;
}

int main(){
    Director* director= new Director();
    ClientCode(*director);
    delete director;
    return 0;    
}
```

输出：

```
Standard basic product:
Product parts: PartA1

Standard full featured product:
Product parts: PartA1, PartB1, PartC1

Custom product:
Product parts: PartA1, PartC1
```

