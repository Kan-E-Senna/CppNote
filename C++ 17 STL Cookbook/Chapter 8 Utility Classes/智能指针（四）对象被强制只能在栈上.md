# 智能指针（四）对象被强制只能在栈上

有的时候我们可能会要求对象只能建构在栈上，这种情况下，对象的new和delete都是私有的，这个时候就无法直接使用智能指针，因为智能指针创建和销毁对象都需要调用new和delete，这种情况下，需要我们另外告诉智能指针构造函数和析构函数。假如我们有如下的类：

```c++
class Foo{
private:
    std::string name;
public:
    Foo(std::string n):name{std::move(n)}{
        std::cout << "Constructor, name = " << name << std::endl;
    };
    ~Foo(){
        std::cout << "Destructor, name = " << name << std::endl;
    }
    static Foo* create(std::string n){
        return new Foo(std::move(n));
    }
    static void destory(Foo *p){
        delete p;
    }
    const std::string& getname(){
        return name;
    }
};

```

这里的对象没有被强制在栈上，但另外有构造函数create和析构函数destory。注意关键字是static，这样我们就可以直接通过Foo::create和Foo::destory调用这两个函数，而不必创建对象。create的返回类型和destory的参数都需要是一个普通指针。

接着，可以使用如下的函数来返回智能指针（因为make_shared和make_unique不能用了(存疑)）

```c++
static std::shared_ptr<Foo> make_shared_foo(std::string n){
    return {Foo::create(std::move(n)), Foo::destory};
}

static std::unique_ptr<Foo, void(*)(Foo*)> make_unique_foo(std::string n){
    return {Foo::create(std::move(n)), Foo::destory};
}
```

注意第5行，unique_ptr有第二个模板参数void(\*)(Foo\*).

接着就可以在main函数调用这两个函数了：

```c++
int main() {
    auto sp = make_shared_foo("Object pointed by shared_ptr");
    auto up = make_shared_foo("Object pointed by unique_ptr");
    return 0;
}
```

输出：

```shell
Constructor, name = Object pointed by shared_ptr
Constructor, name = Object pointed by unique_ptr
Destructor, name = Object pointed by unique_ptr
Destructor, name = Object pointed by shared_ptr
```

当然，也可以直接赋值：

```c++
int main() {
    std::shared_ptr<Foo> p {Foo::create("Object pointed by shared_ptr"s), Foo::destory};
    std::unique_ptr<Foo, void(*)(Foo*)> p2 {Foo::create("Object pointed by unique_ptr"s), Foo::destory};
    return 0;
}
```

输出是一样的。